diff --git a/src/arena_tree.rs b/src/arena_tree.rs
index c39186f..8ccc32c 100644
--- a/src/arena_tree.rs
+++ b/src/arena_tree.rs
@@ -27,6 +27,284 @@ pub struct Node<'a, T: 'a> {
     pub data: T,
 }
 
+#[cfg(feature = "serde")]
+mod serde_impls {
+    use super::Node;
+    use std::collections::HashMap;
+
+    use serde::{de::Error as DeError, Deserialize, Serialize, Serializer};
+    use typed_arena::Arena;
+
+    /// Serializable representation of a Node for serde.
+    ///
+    /// Avoids cycles during serialization/deserialization by using integer
+    /// indices instead of actual references. These are resolved during
+    /// deserialization into actual references after all nodes are created.
+    ///
+    /// All indices are relative to the [`WireTree::nodes`] array, which holds
+    /// all nodes in the tree and acts as a temporary arena for this purpose.
+    #[derive(Default, Serialize, Deserialize)]
+    struct WireNode<T> {
+        parent: Option<u32>,
+        #[serde(default, skip_serializing_if = "Option::is_none")]
+        previous_sibling: Option<u32>,
+        #[serde(default, skip_serializing_if = "Option::is_none")]
+        next_sibling: Option<u32>,
+        #[serde(default, skip_serializing_if = "Option::is_none")]
+        first_child: Option<u32>,
+        #[serde(default, skip_serializing_if = "Option::is_none")]
+        last_child: Option<u32>,
+        data: T,
+    }
+
+    /// Serializable representation of an arena tree for serde.
+    ///
+    /// Holds all nodes in a flat vector to avoid cycles during
+    /// serialization and deserialization. References between nodes are represented
+    /// as integer indices in the array. These are resolved during the final
+    /// resolution step of deserialization, after all nodes are created, into
+    /// actual references and [`Node`] structs. This allows serde to serialize
+    /// and deserialize the [`Node`] tree structure without running into issues
+    /// with reference cycles.
+    #[derive(Default, Serialize, Deserialize)]
+    struct WireTree<T> {
+        nodes: Vec<WireNode<T>>,
+    }
+
+    impl<'a, T: 'a> Serialize for Node<'a, T>
+    where
+        T: Serialize,
+    {
+        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+        where
+            S: Serializer,
+        {
+            // Force the borrow of `self` to match the lifetime carried by the
+            // node so it can be threaded through the traversal.
+            let root: &'a Node<'a, T> =
+                unsafe { std::mem::transmute::<&Node<'a, T>, &'a Node<'a, T>>(self) };
+            let mut ordered = Vec::new();
+            for node in root.descendants() {
+                ordered.push(node);
+            }
+
+            let mut ids = HashMap::with_capacity(ordered.len());
+            for (idx, node) in ordered.iter().enumerate() {
+                ids.insert(std::ptr::from_ref(*node) as usize, idx as u32);
+            }
+
+            let index_for = |node: Option<&'a Node<'a, T>>| {
+                node.map(|n| ids[&(std::ptr::from_ref(n) as usize)])
+            };
+
+            WireTree {
+                nodes: ordered
+                    .iter()
+                    .map(|node| WireNode {
+                        parent: index_for(node.parent()),
+                        previous_sibling: index_for(node.previous_sibling()),
+                        next_sibling: index_for(node.next_sibling()),
+                        first_child: index_for(node.first_child()),
+                        last_child: index_for(node.last_child()),
+                        data: &node.data,
+                    })
+                    .collect::<Vec<_>>(),
+            }
+            .serialize(serializer)
+        }
+    }
+
+    impl<'a, 'de, T: 'a + 'de> serde::Deserialize<'de> for &'a Node<'a, T>
+    where
+        T: serde::Deserialize<'de>,
+    {
+        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+        where
+            D: serde::Deserializer<'de>,
+        {
+            let WireTree { nodes: wire_nodes } = WireTree::<T>::deserialize(deserializer)?;
+            if wire_nodes.is_empty() {
+                return Err(DeError::custom("cannot deserialize empty tree"));
+            }
+
+            let arena = Box::leak(Box::new(Arena::<Node<'de, T>>::new()));
+            let mut nodes: Vec<&Node<'de, T>> = Vec::with_capacity(wire_nodes.len());
+            let mut peers = Vec::with_capacity(wire_nodes.len());
+
+            for wire in wire_nodes.into_iter() {
+                peers.push((
+                    wire.parent,
+                    wire.previous_sibling,
+                    wire.next_sibling,
+                    wire.first_child,
+                    wire.last_child,
+                ));
+                nodes.push(arena.alloc(Node::new(wire.data)));
+            }
+
+            for (node, peer) in nodes.iter().zip(peers.into_iter()) {
+                let (parent, prev, next, first, last) = peer;
+                let parent_ref =
+                    match parent {
+                        Some(i) => Some(*nodes.get(i as usize).ok_or_else(|| {
+                            DeError::custom(format!("node index {i} out of bounds"))
+                        })?),
+                        None => None,
+                    };
+                let prev_ref =
+                    match prev {
+                        Some(i) => Some(*nodes.get(i as usize).ok_or_else(|| {
+                            DeError::custom(format!("node index {i} out of bounds"))
+                        })?),
+                        None => None,
+                    };
+                let next_ref =
+                    match next {
+                        Some(i) => Some(*nodes.get(i as usize).ok_or_else(|| {
+                            DeError::custom(format!("node index {i} out of bounds"))
+                        })?),
+                        None => None,
+                    };
+                let first_ref =
+                    match first {
+                        Some(i) => Some(*nodes.get(i as usize).ok_or_else(|| {
+                            DeError::custom(format!("node index {i} out of bounds"))
+                        })?),
+                        None => None,
+                    };
+                let last_ref =
+                    match last {
+                        Some(i) => Some(*nodes.get(i as usize).ok_or_else(|| {
+                            DeError::custom(format!("node index {i} out of bounds"))
+                        })?),
+                        None => None,
+                    };
+
+                node.parent.set(parent_ref);
+                node.previous_sibling.set(prev_ref);
+                node.next_sibling.set(next_ref);
+                node.first_child.set(first_ref);
+                node.last_child.set(last_ref);
+            }
+
+            let root = nodes[0];
+            // SAFETY: The arena is leaked, so the references live for the
+            // remainder of the program. Since `T: 'a + 'de`, the data inside
+            // the nodes also live for 'a. Thus, the whole tree rooted at
+            // `root` lives for 'a; shortening the lifetime should be safe.
+            Ok(unsafe { core::mem::transmute::<&Node<'de, T>, &Node<'a, T>>(root) })
+        }
+    }
+
+    #[cfg(test)]
+    mod tests {
+        use crate::nodes::Ast;
+
+        use super::super::*;
+        use serde_json;
+        #[test]
+        fn basic_serialization_roundtrip() {
+            let arena = typed_arena::Arena::new();
+            let root = arena.alloc(Node::new("root"));
+            let child1 = arena.alloc(Node::new("child1"));
+            let child2 = arena.alloc(Node::new("child2"));
+            root.append(child1);
+            root.append(child2);
+
+            let serialized = serde_json::to_string(&root).unwrap();
+            let deserialized: &Node<'_, &str> = serde_json::from_str(&serialized).unwrap();
+
+            assert_eq!(deserialized.data, "root");
+
+            let mut children = deserialized.children();
+            assert_eq!(children.next().unwrap().data, "child1");
+            assert_eq!(children.next().unwrap().data, "child2");
+            assert!(children.next().is_none());
+        }
+
+        #[test]
+        fn empty_tree_serialization_fails() {
+            let result: Result<&Node<'_, &str>, _> = serde_json::from_str(r#"{"nodes":[]}"#);
+            assert!(result.is_err());
+        }
+
+        #[test]
+        fn out_of_bounds_index_fails() {
+            let result: Result<&Node<'_, &str>, _> = serde_json::from_str(
+                r#"{
+    "nodes": [
+        {
+            "first_child": 1,
+            "last_child": 1,
+            "data": "root"
+        }
+    ]
+}"#,
+            );
+            assert!(result.is_err());
+        }
+
+        #[test]
+        /// A more complex tree to ensure references are correctly resolved
+        /// when deserializing a tree with multiple levels and siblings, much
+        /// like our actual parsed AST structures.
+        fn complex_tree_serialization_roundtrip() {
+            use crate::nodes::NodeValue;
+            use crate::options::*;
+            use crate::parse_document;
+            use crate::Arena;
+            let arena = Arena::new();
+            let root = parse_document(
+                &arena,
+                r#"# Hello World
+
+## This is a subtitle
+
+And this a paragraph.
+"#,
+                &Options::default(),
+            );
+
+            let serialized = serde_json::to_string_pretty(&root).unwrap();
+            let deserialized: &Node<'_, RefCell<Ast>> = serde_json::from_str(&serialized).unwrap();
+
+            // Check root node
+            assert!(matches!(deserialized.data().value, NodeValue::Document));
+
+            // Check first child (heading 1)
+            let mut children = deserialized.children();
+
+            let heading1 = children.next().unwrap();
+            assert!(matches!(heading1.data().value, NodeValue::Heading(_)));
+
+            let heading1_text = heading1.first_child().unwrap();
+            assert!(
+                matches!(heading1_text.data().value, NodeValue::Text(ref text) if *text == "Hello World")
+            );
+
+            // Check second child (heading 2)
+            let heading2 = children.next().unwrap();
+            assert!(matches!(heading2.data().value, NodeValue::Heading(_)));
+
+            let heading2_text = heading2.first_child().unwrap();
+            assert!(
+                matches!(heading2_text.data().value, NodeValue::Text(ref text) if *text == "This is a subtitle")
+            );
+
+            // Check third child (paragraph)
+            let paragraph = children.next().unwrap();
+            assert!(matches!(paragraph.data().value, NodeValue::Paragraph));
+
+            let paragraph_text = paragraph.first_child().unwrap();
+            assert!(
+                matches!(paragraph_text.data().value, NodeValue::Text(ref text) if *text == "And this a paragraph.")
+            );
+
+            assert!(children.next().is_none());
+        }
+    }
+}
+
 /// A simple Debug implementation that prints the children as a tree, without
 /// looping through the various interior pointer cycles.
 impl<'a, T: 'a> fmt::Debug for Node<'a, RefCell<T>>
@@ -62,7 +340,7 @@ impl<'a, T> Node<'a, T> {
     ///
     /// Typically, this node needs to be moved into an arena allocator
     /// before it can be used in a tree.
-    pub fn new(data: T) -> Node<'a, T> {
+    pub const fn new(data: T) -> Node<'a, T> {
         Node {
             parent: Cell::new(None),
             first_child: Cell::new(None),
@@ -427,6 +705,23 @@ traverse_iterator! {
     ReverseTraverse: last_child, previous_sibling
 }
 
+impl<'a, T> Node<'a, RefCell<T>> {
+    /// Shorthand for `node.data.borrow()`.
+    pub fn data(&self) -> Ref<'_, T> {
+        self.data.borrow()
+    }
+
+    /// Shorthand for `node.data.try_borrow()`.
+    pub fn try_data(&self) -> Result<Ref<'_, T>, BorrowError> {
+        self.data.try_borrow()
+    }
+
+    /// Shorthand for `node.data.borrow_mut()`.
+    pub fn data_mut(&self) -> RefMut<'_, T> {
+        self.data.borrow_mut()
+    }
+}
+
 #[test]
 fn it_works() {
     struct DropTracker<'a>(&'a Cell<u32>);
@@ -470,20 +765,3 @@ fn it_works() {
 
     assert_eq!(drop_counter.get(), 10);
 }
-
-impl<'a, T> Node<'a, RefCell<T>> {
-    /// Shorthand for `node.data.borrow()`.
-    pub fn data(&self) -> Ref<'_, T> {
-        self.data.borrow()
-    }
-
-    /// Shorthand for `node.data.try_borrow()`.
-    pub fn try_data(&self) -> Result<Ref<'_, T>, BorrowError> {
-        self.data.try_borrow()
-    }
-
-    /// Shorthand for `node.data.borrow_mut()`.
-    pub fn data_mut(&self) -> RefMut<'_, T> {
-        self.data.borrow_mut()
-    }
-}
